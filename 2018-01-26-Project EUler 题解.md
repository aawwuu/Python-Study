https://projecteuler.net/archives

### Problem 1 Multiples of 3 and 5

> If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
>
> Find the sum of all the multiples of 3 or 5 below 1000.

```python
#python
sum(x for x in range(1000) if x % 3 == 0 or x % 5 == 0)
```

### Problem 2 Even Fibonacci numbers

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>
> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
>
> By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

```python
#! /usr/bin/env python
# -*- coding:utf-8 -*-

def fib(n):
    a = 1
    b = 2

    while a < n:
        yield a
        a,b = b,a+b
print "sum =", sum([i for i in fib(40000000) if i%2 == 0])
```

This may be a small improvement.  The Fibonacci series is:

1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610...

Now, replacing an odd number with O and an even with E, we get:

O, O, E, O, O, E, O, O, E, O, O, E, O, O, E...

And so each third number is even.  We don't need to calculate the odd numbers.  Starting from an two odd terms x, y, the series is:

x, y, x + y, x + 2y, 2x + 3y, 3x + 5y

And in Python, my solution is:

```python
def calcE():
	x = y = 1
	sum = 0
	while (sum < 1000000):
		sum += (x + y)
		x, y = x + 2 * y, 2 * x + 3 * y
	return sum
```
There is another beautiful structure hidden beneath this problem:

If we only write the even numbers:

2 8 34 144...

it seems that they obey the following recursive relation: E(n)=4*E(n-1)+E(n-2).*

If we can prove that for the Fibonacci numbers the formula F(n)=4*F(n-3)+F(n-6) holds we have proven this recursion.
$$
F(n) = F(n-1) + F(n-2)
= F(n-2)+F(n-3)+F(n-2)=2 F(n-2) + F(n-3)
= 2(F(n-3)+F(n-4))+F(n-3))=3 F(n-3) + 2 F(n-4)
= 3 F(n-3) + F(n-4) + F(n-5) + F(n-6)
= 4 F(n-3) + F(n-6)
$$



### Problem 3 Largest prime factor

> The prime factors of 13195 are 5, 7, 13 and 29.
>
> What is the largest prime factor of the number 600851475143 ?

```python
def largest_prime_factor(n):
    factor = 1
    while factor < n:
        while n % (factor + 1) == 0:
            n = n / (factor + 1)
        factor += 1
    return factor

print largest_prime_factor(600851475143)
```



### Problem 4 Largest palindrome product

> A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
>
> Find the largest palindrome made from the product of two 3-digit numbers.

本题要求两个三位数乘积产生的最大回文数

判断回文数的方法：

```python
def is_palindrome(n):  
    n=str(n)  
    m=n[::-1]  
    return n==m 
```

本题解法：

```python
def largest_palindrome_product():
    L = {}
    for i in range(100, 1000):
        for j in range(i, 1000):
            m = i * j
            m = str(m)
            n = m[::-1]
            if m == n:
                L['%d*%d'%(i, j)] = i*j

    return max(L.items(), key=lambda x: x[1])

```

### Problem 5 Smallest multiple

> 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
>
> What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?


设整数a，b的最大公约数为d，最小公倍数为m，则有 
$$
m = a * b / d
$$
python实现最大公约数和最小公倍数：

```python
def gcd(a, b):
	return a if b == 0 else gcd(b, a%b)
def lcm(a, b):
	return a * b // gcd(a, b)
```

本题python代码如下：

```python
def gcd(a, b):
	return a if b == 0 else gcd(b, a%b)
def lcm(a, b):
	return a * b // gcd(a, b)
r = 2
for i in range(3, 20):
	r = lcm(r, i)
print r
```

另一种解法：

```python
i = 1
for k in (range(1, 21)):
    if i % k > 0:
        for j in range(1, 21):
            if (i*j) % k == 0:
                i *= j
                break
print i

```


### Problem 7 10001st prime

> By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
>
> What is the 10 001st prime number?

```python
#! /user/bin/env python

import math, time
s = time.time()
def prime_10001st():
    prime_dict = {0:1, 1:2}
    key = 1
    value = 2
    while len(prime_dict) < 10002:
        flag = 1
        value += 1
        for j in range(2, int(math.sqrt(value)) + 1):
            if value % j == 0:
                flag = 0
                break
        if flag == 1:
            key += 1
            prime_dict[key] = value
    return prime_dict[10001]
print prime_10001st()
print time.time() - s

```

### Problem8 Largest product in a series

> The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
>
> 73167176531330624919225119674426574742355349194934
> 96983520312774506326239578318016984801869478851843
> 85861560789112949495459501737958331952853208805511
> 12540698747158523863050715693290963295227443043557
> 66896648950445244523161731856403098711121722383113
> 62229893423380308135336276614282806444486645238749
> 30358907296290491560440772390713810515859307960866
> 70172427121883998797908792274921901699720888093776
> 65727333001053367881220235421809751254540594752243
> 52584907711670556013604839586446706324415722155397
> 53697817977846174064955149290862569321978468622482
> 83972241375657056057490261407972968652414535100474
> 82166370484403199890008895243450658541227588666881
> 16427171479924442928230863465674813919123162824586
> 17866458359124566529476545682848912883142607690042
> 24219022671055626321111109370544217506941658960408
> 07198403850962455444362981230987879927244284909188
> 84580156166097919133875499200524063689912560717606
> 05886116467109405077541002256983155200055935729725
> 71636269561882670428252483600823257530420752963450
>
> Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

求1000个数字中连续13个数的乘积，最大的乘积是多少？

下面的解法只求出了最大乘积，但是没有给出是哪13个数相乘得到的。

```python
#! /usr/bin/env python
# conding:utf-8

digit = ''
with open('num.txt', 'r') as f:
    for line in f.readlines():
        digit = digit + line.strip()

product = []
L = map(int, list(digit))
for i in range(len(L) - 13):
     m = reduce(lambda x, y:x * y, L[i:i + 13])
     product.append(m)
print max(product)
```

python3:这里给出了相乘的13个数

```python
#! /usr/bin/env python3
# conding:utf-8

from functools import reduce
digit = ''
with open('num.txt', 'r') as f:
    for line in f.readlines():
        digit = digit + line.strip()

product = []
L = list(map(int, list(digit)))
for i in range(len(L) - 13):
     m = reduce(lambda x, y:x * y, L[i:i + 13])
     product.append(m)
max_prod = max(product)
print("The max produce is:", max_prod)
print("The thirteen numbers are:", digit[product.index(max_prod):product.index(max_prod) + 13])
```

### Problem 9 Special Pythagorean triplet

A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, 
$$
a^2 + b^2 = c^2For example, 32 + 42 = 9 + 16 = 25 = 52.
$$
For example, 32 + 42 = 9 + 16 = 25 = 52.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.

假设 a<b , 根据直角三角形的性质，有

a + b + c = 1000

3a < a + b + c < 3c

a < 334, c > 334

代码如下：

```python
for a in range(1, 334):
	for c in range(333, 1000):
		b = 1000 - a - c
		if a ** 2 + b ** 2 - c ** 2 == 0:
			print("a, b, c: ", a, b , c)
```



### Problem 10 Summation of primes

The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

Find the sum of all the primes below two million.

直接求：

```python
def is_prime(i):
    assert i > 1
    assert isinstance(i, int)
    flag = 1
    for j in range(2, int(i ** 0.5) + 1):
        if i % j == 0:
            flag = 0
    if flag == 1:
        return i

def sum_of_primes(n):
    sum = 17
    for i in range(n)[11:n:2]:
        if i % 3 == 0:continue
        if i % 5 == 0:continue
        if i % 7 == 0:continue
        if is_prime(i):
            sum += is_prime(i)
    return sum

print sum_of_primes(2 * 10 ** 6)

```

筛法：用筛法检定素数降低了时间复杂度，见埃拉托斯特尼筛法

```python
marked = [0] * 200000000
value = 3 #从3开始筛选素数
s = 2 #现在和是2
while value < 200000000:
    if marked[value] == 0: #没有置为1，说明是素数
        s += value
        i = value
        while i < 200000000:
            marked[i] = 1 #筛选出i的倍数，置为1，即排除合数
            i += value
    value += 2 #因为2以外的偶数肯定是合数，因此每次+2
print(s)
```

### Problem 11 Largest product in a grid

> In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
>
> 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
> 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
> 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
> 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
> 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
> 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
> 32 98 81 28 64 23 67 10 **26** 38 40 67 59 54 70 66 18 38 64 70
> 67 26 20 68 02 62 12 20 95 **63** 94 39 63 08 40 91 66 49 94 21
> 24 55 58 05 66 73 99 26 97 17 **78** 78 96 83 14 88 34 89 63 72
> 21 36 23 09 75 00 76 44 20 45 35 **14** 00 61 33 97 34 31 33 95
> 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
> 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
> 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
> 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
> 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
> 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
> 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
> 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
> 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
> 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
>
> The product of these numbers is 26 × 63 × 78 × 14 = 1788696.

要求20×20的方格中，一条直线上连续4个数乘积的最大值，包括横、竖和两条对角线4个方向

用python暴力求，首先将数字放入num.txt中，创建数组

注意到一个4X4方格中，只需要计算4个乘积，以$num[i][j] $ 开始的向右、下、对角线，以及这个4X4方格的另一条对角线

```python
num = []
with open('num.txt', 'r') as f:
    for line in f.readlines():
        line = line.strip().split()
        line = map(int, line)
        a = []
        for i in line:
              a.append(i)      
        num.append(a)
prod_max = 0
for i in range(17):
    for j in range(17):
        prod0 = num[i][j] * num[i][j+1] * num[i][j+2] * num[i][j+3]
        prod1 = num[i][j] * num[i+1][j] * num[i+2][j] * num[i+3][j]
        prod2 = num[i][j] * num[i+1][j+1] * num[i+2][j+2] * num[i+3][j+3]
        prod3 = num[i+3][j] * num[i+2][j+1] * num[i+1][j+2] * num[i][j+3]
        prod = max(prod0, prod1, prod2, prod3)
        if prod > prod_max: prod_max = prod
print(prod_max)
```

### Problem 12   Highly divisible triangular number



